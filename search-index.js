var searchIndex = {};
searchIndex["zmq"] = {"doc":"Module: zmq","items":[[3,"Message","zmq","Holds a 0MQ message.",null,null],[3,"Context","","Handle for a 0MQ context, used to create sockets.",null,null],[3,"Socket","","A socket, the central object in 0MQ.",null,null],[3,"PollEvents","","Type representing pending socket events.",null,null],[3,"PollItem","","Represents a handle that can be `poll()`ed.",null,null],[3,"CurveKeyPair","","A CURVE key pair generated by 0MQ.",null,null],[12,"public_key","","",0,null],[12,"secret_key","","",0,null],[4,"SocketType","","Socket types",null,null],[13,"PAIR","","",1,null],[13,"PUB","","",1,null],[13,"SUB","","",1,null],[13,"REQ","","",1,null],[13,"REP","","",1,null],[13,"DEALER","","",1,null],[13,"ROUTER","","",1,null],[13,"PULL","","",1,null],[13,"PUSH","","",1,null],[13,"XPUB","","",1,null],[13,"XSUB","","",1,null],[13,"STREAM","","",1,null],[4,"Mechanism","","Security Mechanism",null,null],[13,"ZMQ_NULL","","",2,null],[13,"ZMQ_PLAIN","","",2,null],[13,"ZMQ_CURVE","","",2,null],[13,"ZMQ_GSSAPI","","",2,null],[4,"Error","","An error returned by a 0MQ API function.",null,null],[13,"EACCES","","",3,null],[13,"EADDRINUSE","","",3,null],[13,"EAGAIN","","",3,null],[13,"EBUSY","","",3,null],[13,"ECONNREFUSED","","",3,null],[13,"EFAULT","","",3,null],[13,"EINTR","","",3,null],[13,"EHOSTUNREACH","","",3,null],[13,"EINPROGRESS","","",3,null],[13,"EINVAL","","",3,null],[13,"EMFILE","","",3,null],[13,"EMSGSIZE","","",3,null],[13,"ENAMETOOLONG","","",3,null],[13,"ENODEV","","",3,null],[13,"ENOENT","","",3,null],[13,"ENOMEM","","",3,null],[13,"ENOTCONN","","",3,null],[13,"ENOTSOCK","","",3,null],[13,"EPROTO","","",3,null],[13,"EPROTONOSUPPORT","","",3,null],[13,"ENOTSUP","","",3,null],[13,"ENOBUFS","","",3,null],[13,"ENETDOWN","","",3,null],[13,"EADDRNOTAVAIL","","",3,null],[13,"EFSM","","",3,null],[13,"ENOCOMPATPROTO","","",3,null],[13,"ETERM","","",3,null],[13,"EMTHREAD","","",3,null],[4,"EncodeError","","Errors that can occur while encoding Z85.",null,null],[13,"BadLength","","",4,null],[13,"FromUtf8Error","","",4,null],[4,"DecodeError","","Errors that can occur while decoding Z85.",null,null],[13,"BadLength","","The input string slice's length was not a multiple of 5.",5,null],[13,"NulError","","The input string slice had embedded NUL bytes.",5,null],[5,"version","","Return the current zeromq version, as `(major, minor, patch)`.",null,null],[5,"poll","","Poll for events on multiple sockets.",null,null],[5,"proxy","","Start a 0MQ proxy in the current thread.",null,{"inputs":[{"name":"socket"},{"name":"socket"}],"output":{"name":"result"}}],[5,"proxy_with_capture","","Start a 0MQ proxy in the current thread, with a capture socket.",null,{"inputs":[{"name":"socket"},{"name":"socket"},{"name":"socket"}],"output":{"name":"result"}}],[5,"has","","Return true if the used 0MQ library has the given capability.",null,{"inputs":[{"name":"str"}],"output":{"generics":["bool"],"name":"option"}}],[5,"z85_encode","","Encode a binary key as Z85 printable text.",null,null],[5,"z85_decode","","Decode a binary key from Z85-encoded text.",null,{"inputs":[{"name":"str"}],"output":{"generics":["vec","decodeerror"],"name":"result"}}],[11,"drop","","",6,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create an empty `Message`.",6,{"inputs":[],"output":{"name":"message"}}],[11,"with_capacity_unallocated","","Create a `Message` preallocated with `len` uninitialized bytes.",6,{"inputs":[{"name":"usize"}],"output":{"name":"message"}}],[11,"with_capacity","","Create a `Message` with space for `len` bytes that are initialized to 0.",6,{"inputs":[{"name":"usize"}],"output":{"name":"message"}}],[11,"from_slice","","Create a `Message` from a `&[u8]`. This will copy `data` into the message.",6,null],[11,"as_str","","Return the message content as a string slice if it is valid UTF-8.",6,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"get_more","","Return the `ZMQ_MORE` flag, which indicates if more parts of a multipart message will follow.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"gets","","Query a message metadata property.",6,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["str"],"name":"option"}}],[11,"deref","","",6,null],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"name":"bool"}}],[11,"deref_mut","","",6,null],[11,"from","","Construct from a byte slice by copying the data.",6,null],[11,"from","","Construct from a byte vector without copying the data.",6,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"self"}}],[11,"from","","Construct from a string slice by copying the UTF-8 data.",6,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","Construct from a string slice by copying the UTF-8 data.",6,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"from","","",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[6,"Result","","`zmq`-specific Result type.",null,null],[7,"DONTWAIT","","Flag for socket `send` methods that specifies non-blocking mode.",null,null],[7,"SNDMORE","","Flag for socket `send` methods that specifies that more frames of a multipart message will follow.",null,null],[17,"POLLIN","","For `poll()`, specifies to signal when a message/some data can be read from a socket.",null,null],[17,"POLLOUT","","For `poll()`, specifies to signal when a message/some data can be written to a socket.",null,null],[17,"POLLERR","","For `poll()`, specifies to signal when an error condition is present on a socket.  This only applies to non-0MQ sockets.",null,null],[8,"Sendable","","Sendable over a `Socket`.",null,null],[10,"send","","",7,{"inputs":[{"name":"self"},{"name":"socket"},{"name":"i32"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"sockettype"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"sockettype"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"mechanism"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"mechanism"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"to_raw","","",3,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"from_raw","","",3,{"inputs":[{"name":"i32"}],"output":{"name":"error"}}],[11,"description","","",3,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Return the error string for an error.",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"new","","Create a new reference-counted context handle.",8,{"inputs":[],"output":{"name":"context"}}],[11,"socket","","Create a new socket.",8,{"inputs":[{"name":"self"},{"name":"sockettype"}],"output":{"generics":["socket"],"name":"result"}}],[11,"destroy","","Try to destroy the context. This is different than the destructor; the destructor will loop when zmq_ctx_destroy returns EINTR.",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"default","","",8,{"inputs":[],"output":{"name":"self"}}],[11,"drop","","",9,{"inputs":[{"name":"self"}],"output":null}],[11,"into_raw","","Consume the Socket and return the raw socket pointer.",9,null],[11,"from_raw","","Create a Socket from a raw socket pointer.",9,null],[11,"as_mut_ptr","","Return the inner pointer to this Socket.",9,null],[11,"bind","","Accept connections on a socket.",9,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"connect","","Connect a socket.",9,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"disconnect","","Disconnect a previously connected socket",9,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"send","","Send a message.",9,{"inputs":[{"name":"self"},{"name":"t"},{"name":"i32"}],"output":{"name":"result"}}],[11,"send_msg","","Send a `Message` message.",9,{"inputs":[{"name":"self"},{"name":"message"},{"name":"i32"}],"output":{"name":"result"}}],[11,"send_str","","",9,{"inputs":[{"name":"self"},{"name":"str"},{"name":"i32"}],"output":{"name":"result"}}],[11,"send_multipart","","",9,{"inputs":[{"name":"self"},{"name":"i"},{"name":"i32"}],"output":{"name":"result"}}],[11,"recv","","Receive a message into a `Message`. The length passed to zmq_msg_recv is the length of the buffer.",9,{"inputs":[{"name":"self"},{"name":"message"},{"name":"i32"}],"output":{"name":"result"}}],[11,"recv_into","","Receive bytes into a slice. The length passed to `zmq_recv` is the length of the slice. The return value is the number of bytes in the message, which may be larger than the length of the slice, indicating truncation.",9,null],[11,"recv_msg","","Receive a message into a fresh `Message`.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["message"],"name":"result"}}],[11,"recv_bytes","","Receive a message as a byte vector.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"recv_string","","Receive a `String` from the socket.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["result"],"name":"result"}}],[11,"recv_multipart","","Receive a multipart message from the socket.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"is_ipv6","","Accessor for the `ZMQ_IPV6` option.",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_ipv6","","Accessor for the `ZMQ_IPV6` option.",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_immediate","","Accessor for the `ZMQ_IMMEDIATE` option.",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_immediate","","Accessor for the `ZMQ_IMMEDIATE` option.",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_plain_server","","Accessor for the `ZMQ_PLAIN_SERVER` option.",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_plain_server","","Accessor for the `ZMQ_PLAIN_SERVER` option.",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_conflate","","Accessor for the `ZMQ_CONFLATE` option.",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_conflate","","Accessor for the `ZMQ_CONFLATE` option.",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_probe_router","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_probe_router","","",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_router_mandatory","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_router_mandatory","","",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"is_curve_server","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_curve_server","","",9,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"get_socket_type","","Return the type of this socket.",9,{"inputs":[{"name":"self"}],"output":{"generics":["sockettype"],"name":"result"}}],[11,"get_rcvmore","","Return true if there are more frames of a multipart message to receive.",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"get_maxmsgsize","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i64"],"name":"result"}}],[11,"set_maxmsgsize","","",9,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"result"}}],[11,"get_sndhwm","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_sndhwm","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_rcvhwm","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_rcvhwm","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_affinity","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["u64"],"name":"result"}}],[11,"set_affinity","","",9,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"result"}}],[11,"get_rate","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_rate","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_recovery_ivl","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_recovery_ivl","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_sndbuf","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_sndbuf","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_rcvbuf","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_rcvbuf","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_tos","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_tos","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_linger","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_linger","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_reconnect_ivl","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_reconnect_ivl","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_reconnect_ivl_max","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_reconnect_ivl_max","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_backlog","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_backlog","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_fd","","Get the event notification file descriptor.",9,{"inputs":[{"name":"self"}],"output":{"generics":["rawfd"],"name":"result"}}],[11,"get_events","","Get the currently pending events.",9,{"inputs":[{"name":"self"}],"output":{"generics":["pollevents"],"name":"result"}}],[11,"get_multicast_hops","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_multicast_hops","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_rcvtimeo","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_rcvtimeo","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_sndtimeo","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_sndtimeo","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_tcp_keepalive","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_tcp_keepalive","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_tcp_keepalive_cnt","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_tcp_keepalive_cnt","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_tcp_keepalive_idle","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_tcp_keepalive_idle","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_tcp_keepalive_intvl","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_tcp_keepalive_intvl","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_handshake_ivl","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"result"}}],[11,"set_handshake_ivl","","",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"result"}}],[11,"set_identity","","",9,null],[11,"set_subscribe","","",9,null],[11,"set_unsubscribe","","",9,null],[11,"get_identity","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"result"}}],[11,"get_socks_proxy","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"result"}}],[11,"get_mechanism","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["mechanism"],"name":"result"}}],[11,"get_plain_username","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"result"}}],[11,"get_plain_password","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"result"}}],[11,"get_zap_domain","","",9,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"result"}}],[11,"get_last_endpoint","","Return the address of the last endpoint this socket was bound to.",9,{"inputs":[{"name":"self"}],"output":{"generics":["result"],"name":"result"}}],[11,"get_curve_publickey","","Set the `ZMQ_CURVE_PUBLICKEY` option value.",9,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"result"}}],[11,"get_curve_secretkey","","Get the `ZMQ_CURVE_SECRETKEY` option value.",9,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"result"}}],[11,"get_curve_serverkey","","Get `ZMQ_CURVE_SERVERKEY` option value.",9,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"result"}}],[11,"set_socks_proxy","","",9,{"inputs":[{"name":"self"},{"generics":["str"],"name":"option"}],"output":{"name":"result"}}],[11,"set_plain_username","","",9,{"inputs":[{"name":"self"},{"generics":["str"],"name":"option"}],"output":{"name":"result"}}],[11,"set_plain_password","","",9,{"inputs":[{"name":"self"},{"generics":["str"],"name":"option"}],"output":{"name":"result"}}],[11,"set_zap_domain","","",9,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_curve_publickey","","",9,null],[11,"set_curve_secretkey","","",9,null],[11,"set_curve_serverkey","","",9,null],[11,"as_poll_item","","Create a `PollItem` from the socket.",9,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"pollitem"}}],[11,"poll","","Do a call to `zmq_poll` with only this socket.",9,{"inputs":[{"name":"self"},{"name":"pollevents"},{"name":"i64"}],"output":{"generics":["i32"],"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"pollevents"}}],[11,"partial_cmp","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"le","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"gt","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"ge","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"cmp","","",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"ordering"}}],[11,"hash","","",10,null],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",10,{"inputs":[],"output":{"name":"pollevents"}}],[11,"all","","Returns the set containing all flags.",10,{"inputs":[],"output":{"name":"pollevents"}}],[11,"bits","","Returns the raw value of the flags currently stored.",10,{"inputs":[{"name":"self"}],"output":{"name":"i16"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",10,{"inputs":[{"name":"i16"}],"output":{"generics":["pollevents"],"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",10,{"inputs":[{"name":"i16"}],"output":{"name":"pollevents"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"pollevents"}}],[11,"bitor_assign","","Adds the set of flags.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"pollevents"}}],[11,"bitxor_assign","","Toggles the set of flags.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"pollevents"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":{"name":"pollevents"}}],[11,"sub_assign","","Disables all flags enabled in the set.",10,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",10,{"inputs":[{"name":"self"}],"output":{"name":"pollevents"}}],[11,"extend","","",10,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",10,{"inputs":[{"name":"t"}],"output":{"name":"pollevents"}}],[11,"from_fd","","Construct a PollItem from a non-0MQ socket, given by its file descriptor and the events that should be polled.",11,{"inputs":[{"name":"rawfd"},{"name":"pollevents"}],"output":{"name":"pollitem"}}],[11,"set_events","","Change the events to wait for.",11,{"inputs":[{"name":"self"},{"name":"pollevents"}],"output":null}],[11,"get_revents","","Retrieve the events that occurred for this handle.",11,{"inputs":[{"name":"self"}],"output":{"name":"pollevents"}}],[11,"is_readable","","Returns true if the polled socket has messages ready to receive.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_writable","","Returns true if the polled socket can accept messages to be sent without blocking.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_error","","Returns true if the polled socket encountered an error condition.",11,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new key pair.",0,{"inputs":[],"output":{"generics":["curvekeypair"],"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",4,{"inputs":[{"name":"fromutf8error"}],"output":{"name":"self"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",5,{"inputs":[{"name":"nulerror"}],"output":{"name":"self"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",5,{"inputs":[{"name":"self"}],"output":{"name":"str"}}]],"paths":[[3,"CurveKeyPair"],[4,"SocketType"],[4,"Mechanism"],[4,"Error"],[4,"EncodeError"],[4,"DecodeError"],[3,"Message"],[8,"Sendable"],[3,"Context"],[3,"Socket"],[3,"PollEvents"],[3,"PollItem"]]};
searchIndex["zmq_mio"] = {"doc":"Asynchronous `ØMQ`, a.k.a.`(ZeroMQ)` in `Rust` with `mio`.","items":[[3,"Context","zmq_mio","Wrapper for ØMQ context.",null,null],[3,"Socket","","Asynchronous ØMQ socket.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"context"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `Context` instance. Use the `Context::socket` method to create sockets that can talk via `inproc://*` addresses.",0,{"inputs":[],"output":{"name":"self"}}],[11,"socket","","Create a new `Socket` instance for asynchronous communications.",0,{"inputs":[{"name":"self"},{"name":"sockettype"}],"output":{"generics":["socket"],"name":"result"}}],[11,"destroy","","Try to destroy the underlying context. This is different than the destructor; the destructor will loop when zmq_ctx_destroy returns EINTR.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"get_inner","","Get a cloned instance of the underlying `zmq::Context`.",0,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new event-wrapped ØMQ socket. Takes an existing `zmq::Socket` instance as an only argument.",1,{"inputs":[{"name":"socket"}],"output":{"name":"self"}}],[11,"as_raw_fd","","Returns an `io::Result` with the raw socket file-descriptor.",1,{"inputs":[{"name":"self"}],"output":{"generics":["rawfd"],"name":"result"}}],[11,"get_ref","","Returns a reference to the underlying `zmq::Socket`. Useful for setting socket options at runtime.",1,{"inputs":[{"name":"self"}],"output":{"name":"socket"}}],[11,"bind","","Bind the socket to the given address.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"connect","","Connect the socket to the given address.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_subscribe","","Subscribe this socket to the given `prefix`.",1,null],[11,"send","","Send a message.",1,{"inputs":[{"name":"self"},{"name":"t"},{"name":"i32"}],"output":{"name":"result"}}],[11,"send_multipart","","Send a multi-part message. Takes any iterator of valid message types.",1,{"inputs":[{"name":"self"},{"name":"i"},{"name":"i32"}],"output":{"name":"result"}}],[11,"get_rcvmore","","Return true if there are more frames of a multipart message to receive.",1,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"recv","","Read a single `zmq::Message` from the socket. Any flags set will be combined with `zmq::DONTWAIT`, which is needed for non-blocking mode. The internal `zmq::Error::EAGAIN` is automatically translated to `io::ErrorKind::WouldBlock`, which you MUST handle without failing.",1,{"inputs":[{"name":"self"},{"name":"message"},{"name":"i32"}],"output":{"name":"result"}}],[11,"recv_into","","Receive bytes into a slice. The length passed to `zmq_recv` is the length of the slice. The return value is the number of bytes in the message, which may be larger than the length of the slice, indicating truncation.",1,null],[11,"recv_msg","","Receive a message into a fresh `zmq::Message`.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["message"],"name":"result"}}],[11,"recv_bytes","","Receive a message as a byte vector.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"recv_string","","Receive a `String` from the socket.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["result"],"name":"result"}}],[11,"recv_multipart","","Receive a multipart message from the socket.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"get_socket_type","","Get the SocketType",1,{"inputs":[{"name":"self"}],"output":{"generics":["sockettype"],"name":"result"}}],[11,"read","","Asynchronously read a byte buffer from the `Socket`.",1,null],[11,"write","","Asynchronously write a byte buffer to the `Socket`.",1,null],[11,"flush","","Flush is not implemented since ØMQ guarantees that a message is either fully sent, or not sent at all.",1,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"register","","",1,{"inputs":[{"name":"self"},{"name":"poll"},{"name":"token"},{"name":"ready"},{"name":"pollopt"}],"output":{"name":"result"}}],[11,"reregister","","",1,{"inputs":[{"name":"self"},{"name":"poll"},{"name":"token"},{"name":"ready"},{"name":"pollopt"}],"output":{"name":"result"}}],[11,"deregister","","",1,{"inputs":[{"name":"self"},{"name":"poll"}],"output":{"name":"result"}}]],"paths":[[3,"Context"],[3,"Socket"]]};
searchIndex["zmq_tokio"] = {"doc":"ØMQ (ZeroMQ) for tokio ======================","items":[[3,"Error","zmq_tokio","The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and associated traits.",null,null],[3,"Message","","Holds a 0MQ message.",null,null],[3,"Context","","Wrapper for `zmq::Context`.",null,null],[3,"Socket","","Poll-evented ØMQ socket. Can be used directly on transports implementing `futures::stream::Stream` and `futures::sink::Sink`.",null,null],[3,"SocketFramed","","A custom transport type for `Socket`.",null,null],[5,"convert_into_tokio_socket","","Convert an `zmq::Socket` instance into `zmq_tokio::Socket`.",null,{"inputs":[{"name":"socket"},{"name":"handle"}],"output":{"generics":["socket"],"name":"result"}}],[0,"future","","Futures for ØMQ sockets.",null,null],[3,"SendMessage","zmq_tokio::future","A Future that sends a `Message` asynchronously. This is returned by `Socket::send`",null,null],[3,"SendMultipartMessage","","A Future that sends a multi-part `Message` asynchronously. This is returned by `Socket::send_multipart`",null,null],[3,"ReceiveMultipartMessage","","A Future that receives a multi-part `Message` asynchronously. This is returned by `Socket::recv_multipart`",null,null],[3,"ReceiveMessage","","A Future that receives a `Message` asynchronously. This is returned by `Socket::recv`",null,null],[11,"new","","",0,{"inputs":[{"name":"socket"},{"name":"message"}],"output":{"name":"sendmessage"}}],[11,"poll","","",0,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",1,{"inputs":[{"name":"socket"},{"name":"i"}],"output":{"name":"sendmultipartmessage"}}],[11,"poll","","",1,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",2,{"inputs":[{"name":"socket"}],"output":{"name":"receivemultipartmessage"}}],[11,"poll","","",2,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",3,{"inputs":[{"name":"socket"}],"output":{"name":"receivemessage"}}],[11,"poll","","",3,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[0,"stream","zmq_tokio","Streams for sockets.",null,null],[3,"MessageStream","zmq_tokio::stream","Single-message stream for sockets.",null,null],[3,"MultipartMessageStream","","Multipart-message stream for sockets.",null,null],[11,"new","","",4,{"inputs":[{"name":"t"}],"output":{"name":"messagestream"}}],[11,"poll","","",4,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"new","","",5,{"inputs":[{"name":"t"}],"output":{"name":"multipartmessagestream"}}],[11,"poll","","",5,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[0,"transport","zmq_tokio","Tokio transports for sockets.",null,null],[3,"MessageTransport","zmq_tokio::transport","Tokio transport for one-part messages.",null,null],[3,"MultipartMessageTransport","","Tokio transport for multipart-messages.",null,null],[11,"new","","",6,{"inputs":[{"name":"t"}],"output":{"name":"messagetransport"}}],[11,"start_send","","",6,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"generics":["message"],"name":"startsend"}}],[11,"poll_complete","","",6,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",6,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"new","","",7,{"inputs":[{"name":"t"}],"output":{"name":"multipartmessagetransport"}}],[11,"start_send","","",7,{"inputs":[{"name":"self"},{"generics":["vec"],"name":"vec"}],"output":{"generics":["vec"],"name":"startsend"}}],[11,"poll_complete","","",7,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",7,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[8,"SocketSend","zmq_tokio","API methods for sending messages with sockets.",null,null],[10,"send","","Send a message.",8,{"inputs":[{"name":"self"},{"name":"t"},{"name":"i32"}],"output":{"name":"result"}}],[10,"send_multipart","","Sends a multipart-message.",8,{"inputs":[{"name":"self"},{"name":"i"},{"name":"i32"}],"output":{"name":"result"}}],[8,"SocketRecv","","API methods for receiving messages with sockets.",null,null],[10,"get_rcvmore","","Return true if there are more frames of a multipart message to receive.",9,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[10,"recv","","Receive a message into a `Message`. The length passed to `zmq_msg_recv` is the length of the buffer.",9,{"inputs":[{"name":"self"},{"name":"message"},{"name":"i32"}],"output":{"name":"result"}}],[10,"recv_into","","Receive bytes into a slice. The length passed to `zmq_recv` is the length of the slice. The return value is the number of bytes in the message, which may be larger than the length of the slice, indicating truncation.",9,null],[10,"recv_msg","","Receive a message into a fresh `Message`.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["message"],"name":"result"}}],[10,"recv_bytes","","Receive a message as a byte vector.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[10,"recv_string","","Receive a `String` from the socket.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["result"],"name":"result"}}],[10,"recv_multipart","","Receive a multipart message from the socket.",9,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"default","","",10,{"inputs":[],"output":{"name":"context"}}],[11,"new","","Create a new ØMQ context for the `tokio` framework.",10,{"inputs":[],"output":{"name":"context"}}],[11,"socket","","Create a new ØMQ socket for the `tokio` framework.",10,{"inputs":[{"name":"self"},{"name":"sockettype"},{"name":"handle"}],"output":{"generics":["socket"],"name":"result"}}],[11,"destroy","","Try to destroy the underlying context. This is different than the destructor; the destructor will loop when zmq_ctx_destroy returns EINTR.",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"get_inner","","Get a cloned instance of the underlying `zmq_mio::Context`.",10,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"get_ref","","A reference to the underlying `zmq_mio::Socket`. Useful for building futures.",11,{"inputs":[{"name":"self"}],"output":{"name":"pollevented"}}],[11,"bind","","Bind the underlying socket to the given address.",11,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"connect","","Connect the underlying socket to the given address.",11,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_subscribe","","Subscribe the underlying socket to the given prefix.",11,null],[11,"send","","Sends a type implementing `Into<zmq::Message>` as a `Future`.",11,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"sendmessage"}}],[11,"send_multipart","","Sends a type implementing `Into<zmq::Message>` as a `Future`.",11,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"sendmultipartmessage"}}],[11,"recv","","Returns a `Future` that resolves into a `zmq::Message`",11,{"inputs":[{"name":"self"}],"output":{"name":"receivemessage"}}],[11,"recv_multipart","","Returns a `Future` that resolves into a `Vec<zmq::Message>`",11,{"inputs":[{"name":"self"}],"output":{"name":"receivemultipartmessage"}}],[11,"get_socket_type","","Get the SocketType",11,{"inputs":[{"name":"self"}],"output":{"generics":["sockettype"],"name":"result"}}],[11,"framed","","",11,{"inputs":[{"name":"self"}],"output":{"name":"socketframed"}}],[11,"incoming","","Returns a `Stream` of incoming one-part messages.",11,{"inputs":[{"name":"self"}],"output":{"generics":["pollevented"],"name":"messagestream"}}],[11,"incoming_multipart","","Returns a `Stream` of incoming multipart-messages.",11,{"inputs":[{"name":"self"}],"output":{"generics":["pollevented"],"name":"multipartmessagestream"}}],[11,"read","","",11,null],[11,"write","","",11,null],[11,"flush","","",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","",11,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"poll"}}],[11,"start_send","","",12,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"generics":["message"],"name":"startsend"}}],[11,"poll_complete","","",12,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",12,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"new","","Creates a new I/O error from a known kind of error as well as an arbitrary error payload.",13,{"inputs":[{"name":"errorkind"},{"name":"e"}],"output":{"name":"error"}}],[11,"last_os_error","","Returns an error representing the last OS error which occurred.",13,{"inputs":[],"output":{"name":"error"}}],[11,"from_raw_os_error","","Creates a new instance of an `Error` from a particular OS error code.",13,{"inputs":[{"name":"i32"}],"output":{"name":"error"}}],[11,"raw_os_error","","Returns the OS error that this error represents (if any).",13,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"option"}}],[11,"get_ref","","Returns a reference to the inner error wrapped by this error (if any).",13,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"get_mut","","Returns a mutable reference to the inner error wrapped by this error (if any).",13,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"into_inner","","Consumes the `Error`, returning its inner error (if any).",13,{"inputs":[{"name":"self"}],"output":{"generics":["box"],"name":"option"}}],[11,"kind","","Returns the corresponding `ErrorKind` for this error.",13,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"description","","",13,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"from","","",13,{"inputs":[{"name":"nulerror"}],"output":{"name":"error"}}],[11,"from","","",13,{"inputs":[{"name":"intoinnererror"}],"output":{"name":"error"}}],[11,"from","","",13,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"deref_mut","","",14,null],[11,"drop","","",14,null],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"name":"bool"}}],[11,"from","","",14,{"inputs":[{"name":"t"}],"output":{"name":"message"}}],[11,"from","","Construct from a string slice by copying the UTF-8 data.",14,{"inputs":[{"name":"string"}],"output":{"name":"message"}}],[11,"from","","Construct from a byte slice by copying the data.",14,null],[11,"from","","Construct from a string slice by copying the UTF-8 data.",14,{"inputs":[{"name":"str"}],"output":{"name":"message"}}],[11,"from","","Construct from a byte vector without copying the data.",14,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"message"}}],[11,"from","","",13,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"deref","","",14,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"new","","Create an empty `Message`.",14,{"inputs":[],"output":{"name":"message"}}],[11,"with_capacity_unallocated","","Create a `Message` preallocated with `len` uninitialized bytes.",14,{"inputs":[{"name":"usize"}],"output":{"name":"message"}}],[11,"with_capacity","","Create a `Message` with space for `len` bytes that are initialized to 0.",14,{"inputs":[{"name":"usize"}],"output":{"name":"message"}}],[11,"from_slice","","Create a `Message` from a `&[u8]`. This will copy `data` into the message.",14,null],[11,"as_str","","Return the message content as a string slice if it is valid UTF-8.",14,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"get_more","","Return the `ZMQ_MORE` flag, which indicates if more parts of a multipart message will follow.",14,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"gets","","Query a message metadata property.",14,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["str"],"name":"option"}}]],"paths":[[3,"SendMessage"],[3,"SendMultipartMessage"],[3,"ReceiveMultipartMessage"],[3,"ReceiveMessage"],[3,"MessageStream"],[3,"MultipartMessageStream"],[3,"MessageTransport"],[3,"MultipartMessageTransport"],[8,"SocketSend"],[8,"SocketRecv"],[3,"Context"],[3,"Socket"],[3,"SocketFramed"],[3,"Error"],[3,"Message"]]};
initSearch(searchIndex);
