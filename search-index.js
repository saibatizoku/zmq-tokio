var searchIndex = {};
searchIndex["zmq_mio"] = {"doc":"Asynchronous `ØMQ`, a.k.a.`(ZeroMQ)` in `Rust` with `mio`.","items":[[3,"Context","zmq_mio","Wrapper for ØMQ context.",null,null],[3,"Socket","","Asynchronous ØMQ socket.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"context"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `Context` instance. Use the `Context::socket` method to create sockets that can talk via `inproc://*` addresses.",0,{"inputs":[],"output":{"name":"self"}}],[11,"socket","","Create a new `Socket` instance for asynchronous communications.",0,{"inputs":[{"name":"self"},{"name":"sockettype"}],"output":{"generics":["socket"],"name":"result"}}],[11,"destroy","","Try to destroy the underlying context. This is different than the destructor; the destructor will loop when zmq_ctx_destroy returns EINTR.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"get_inner","","Get a cloned instance of the underlying `zmq::Context`.",0,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new event-wrapped ØMQ socket. Takes an existing `zmq::Socket` instance as an only argument.",1,{"inputs":[{"name":"socket"}],"output":{"name":"self"}}],[11,"as_raw_fd","","Returns an `io::Result` with the raw socket file-descriptor.",1,{"inputs":[{"name":"self"}],"output":{"generics":["rawfd"],"name":"result"}}],[11,"get_ref","","Returns a reference to the underlying `zmq::Socket`. Useful for setting socket options at runtime.",1,{"inputs":[{"name":"self"}],"output":{"name":"socket"}}],[11,"get_mut","","Returns a mutable reference to the underlying `zmq::Socket`. Useful for setting socket options at runtime.",1,{"inputs":[{"name":"self"}],"output":{"name":"socket"}}],[11,"bind","","Bind the socket to the given address.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"connect","","Connect a socket.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"disconnect","","Disconnect a previously connected socket.",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"send","","Send a message.",1,{"inputs":[{"name":"self"},{"name":"t"},{"name":"i32"}],"output":{"name":"result"}}],[11,"send_multipart","","Send a multi-part message. Takes any iterator of valid message types.",1,{"inputs":[{"name":"self"},{"name":"i"},{"name":"i32"}],"output":{"name":"result"}}],[11,"recv","","Read a single `zmq::Message` from the socket. Any flags set will be combined with `zmq::DONTWAIT`, which is needed for non-blocking mode. The internal `zmq::Error::EAGAIN` is automatically translated to `io::ErrorKind::WouldBlock`, which you MUST handle without failing.",1,{"inputs":[{"name":"self"},{"name":"message"},{"name":"i32"}],"output":{"name":"result"}}],[11,"recv_into","","Receive bytes into a slice. The length passed to `zmq_recv` is the length of the slice. The return value is the number of bytes in the message, which may be larger than the length of the slice, indicating truncation.",1,null],[11,"recv_msg","","Receive a message into a fresh `zmq::Message`.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["message"],"name":"result"}}],[11,"recv_bytes","","Receive a message as a byte vector.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"recv_string","","Receive a `String` from the socket.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["result"],"name":"result"}}],[11,"recv_multipart","","Receive a multipart message from the socket.",1,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"generics":["vec"],"name":"result"}}],[11,"get_socket_type","","Return the type of this socket.",1,{"inputs":[{"name":"self"}],"output":{"generics":["sockettype"],"name":"result"}}],[11,"get_rcvmore","","Return true if there are more frames of a multipart message to receive.",1,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_subscribe","","Subscribe this socket to the given `prefix`.",1,null],[11,"set_unsubscribe","","Unsubscribe the underlying socket from the given prefix.",1,null],[11,"read","","Asynchronously read a byte buffer from the `Socket`.",1,null],[11,"write","","Asynchronously write a byte buffer to the `Socket`.",1,null],[11,"flush","","Flush is not implemented since ØMQ guarantees that a message is either fully sent, or not sent at all.",1,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"register","","",1,{"inputs":[{"name":"self"},{"name":"poll"},{"name":"token"},{"name":"ready"},{"name":"pollopt"}],"output":{"name":"result"}}],[11,"reregister","","",1,{"inputs":[{"name":"self"},{"name":"poll"},{"name":"token"},{"name":"ready"},{"name":"pollopt"}],"output":{"name":"result"}}],[11,"deregister","","",1,{"inputs":[{"name":"self"},{"name":"poll"}],"output":{"name":"result"}}]],"paths":[[3,"Context"],[3,"Socket"]]};
searchIndex["zmq_tokio"] = {"doc":"ØMQ (ZeroMQ) for tokio ======================","items":[[3,"Error","zmq_tokio","The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and associated traits.",null,null],[3,"Message","","Holds a 0MQ message.",null,null],[4,"SocketType","","Socket types",null,null],[13,"PAIR","","",0,null],[13,"PUB","","",0,null],[13,"SUB","","",0,null],[13,"REQ","","",0,null],[13,"REP","","",0,null],[13,"DEALER","","",0,null],[13,"ROUTER","","",0,null],[13,"PULL","","",0,null],[13,"PUSH","","",0,null],[13,"XPUB","","",0,null],[13,"XSUB","","",0,null],[13,"STREAM","","",0,null],[7,"SNDMORE","","Flag for socket `send` methods that specifies that more frames of a multipart message will follow.",null,null],[3,"Context","","Wrapper for `zmq::Context`.",null,null],[3,"Socket","","Poll-evented ØMQ socket. Can be used directly on transports implementing `futures::stream::Stream` and `futures::sink::Sink`.",null,null],[3,"SocketFramed","","A custom transport type for `Socket`.",null,null],[0,"future","","Futures for ØMQ sockets.",null,null],[3,"SendMessage","zmq_tokio::future","A Future that sends a `Message` asynchronously. This is returned by `Socket::send`",null,null],[3,"SendMultipartMessage","","A Future that sends a multi-part `Message` asynchronously. This is returned by `Socket::send_multipart`",null,null],[3,"ReceiveMultipartMessage","","A Future that receives a multi-part `Message` asynchronously. This is returned by `Socket::recv_multipart`",null,null],[3,"ReceiveMessage","","A Future that receives a `Message` asynchronously. This is returned by `Socket::recv`",null,null],[11,"new","","",1,{"inputs":[{"name":"socket"},{"name":"message"}],"output":{"name":"sendmessage"}}],[11,"poll","","",1,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",2,{"inputs":[{"name":"socket"},{"name":"i"}],"output":{"name":"sendmultipartmessage"}}],[11,"poll","","",2,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",3,{"inputs":[{"name":"socket"}],"output":{"name":"receivemultipartmessage"}}],[11,"poll","","",3,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"new","","",4,{"inputs":[{"name":"socket"}],"output":{"name":"receivemessage"}}],[11,"poll","","",4,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"clone","zmq_tokio","",5,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"context"}}],[11,"new","","Create a new ØMQ context for the `tokio` framework.",5,{"inputs":[],"output":{"name":"context"}}],[11,"socket","","Create a new ØMQ socket for the `tokio` framework.",5,{"inputs":[{"name":"self"},{"name":"sockettype"},{"name":"handle"}],"output":{"generics":["socket"],"name":"result"}}],[11,"destroy","","Try to destroy the underlying context. This is different than the destructor; the destructor will loop when zmq_ctx_destroy returns EINTR.",5,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"get_inner","","Get a cloned instance of the underlying `zmq_mio::Context`.",5,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"get_ref","","A reference to the underlying `zmq_mio::Socket`. Useful for building futures.",6,{"inputs":[{"name":"self"}],"output":{"name":"socket"}}],[11,"get_mut","","Returns a mutable reference to the underlying `zmq_mio::Socket`. Useful for setting socket options at runtime.",6,{"inputs":[{"name":"self"}],"output":{"name":"socket"}}],[11,"bind","","Bind the underlying socket to the given address.",6,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"connect","","Connect a socket.",6,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"disconnect","","Disconnect a previously connected socket.",6,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"send","","Sends a type implementing `Into<Message>` as a `Future`.",6,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"sendmessage"}}],[11,"send_multipart","","Sends a type implementing `Into<Message>` as a `Future`.",6,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"sendmultipartmessage"}}],[11,"recv","","Returns a `Future` that resolves into a `Message`",6,{"inputs":[{"name":"self"}],"output":{"name":"receivemessage"}}],[11,"recv_multipart","","Returns a `Future` that resolves into a `Vec<Message>`",6,{"inputs":[{"name":"self"}],"output":{"name":"receivemultipartmessage"}}],[11,"get_socket_type","","Return the type of this socket.",6,{"inputs":[{"name":"self"}],"output":{"generics":["sockettype"],"name":"result"}}],[11,"get_rcvmore","","Return true if there are more frames of a multipart message to receive.",6,{"inputs":[{"name":"self"}],"output":{"generics":["bool"],"name":"result"}}],[11,"set_subscribe","","Subscribe the underlying socket to the given prefix.",6,null],[11,"set_unsubscribe","","Unsubscribe the underlying socket from the given prefix.",6,null],[11,"framed","","",6,{"inputs":[{"name":"self"}],"output":{"name":"socketframed"}}],[11,"read","","",6,null],[11,"write","","",6,null],[11,"flush","","",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"shutdown","","",6,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"poll"}}],[11,"start_send","","",7,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"generics":["message"],"name":"startsend"}}],[11,"poll_complete","","",7,{"inputs":[{"name":"self"}],"output":{"name":"poll"}}],[11,"poll","","",7,{"inputs":[{"name":"self"}],"output":{"generics":["option"],"name":"poll"}}],[11,"new","","Creates a new I/O error from a known kind of error as well as an arbitrary error payload.",8,{"inputs":[{"name":"errorkind"},{"name":"e"}],"output":{"name":"error"}}],[11,"last_os_error","","Returns an error representing the last OS error which occurred.",8,{"inputs":[],"output":{"name":"error"}}],[11,"from_raw_os_error","","Creates a new instance of an `Error` from a particular OS error code.",8,{"inputs":[{"name":"i32"}],"output":{"name":"error"}}],[11,"raw_os_error","","Returns the OS error that this error represents (if any).",8,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"option"}}],[11,"get_ref","","Returns a reference to the inner error wrapped by this error (if any).",8,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"get_mut","","Returns a mutable reference to the inner error wrapped by this error (if any).",8,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"into_inner","","Consumes the `Error`, returning its inner error (if any).",8,{"inputs":[{"name":"self"}],"output":{"generics":["box"],"name":"option"}}],[11,"kind","","Returns the corresponding `ErrorKind` for this error.",8,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"from","","",8,{"inputs":[{"name":"nulerror"}],"output":{"name":"error"}}],[11,"from","","",8,{"inputs":[{"name":"errorkind"}],"output":{"name":"error"}}],[11,"from","","",8,{"inputs":[{"name":"intoinnererror"}],"output":{"name":"error"}}],[11,"description","","",8,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",8,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"from","","Construct from a byte vector without copying the data.",9,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"message"}}],[11,"from","","",9,{"inputs":[{"name":"t"}],"output":{"name":"message"}}],[11,"from","","Construct from a string slice by copying the UTF-8 data.",9,{"inputs":[{"name":"str"}],"output":{"name":"message"}}],[11,"from","","Construct from a byte slice by copying the data.",9,null],[11,"from","","",8,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","Construct from a string slice by copying the UTF-8 data.",9,{"inputs":[{"name":"string"}],"output":{"name":"message"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"sockettype"}}],[11,"deref","","",9,null],[11,"deref_mut","","",9,null],[11,"drop","","",9,null],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"sockettype"}],"output":{"name":"bool"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"message"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"new","","Create an empty `Message`.",9,{"inputs":[],"output":{"name":"message"}}],[11,"with_capacity_unallocated","","Create a `Message` preallocated with `len` uninitialized bytes.",9,{"inputs":[{"name":"usize"}],"output":{"name":"message"}}],[11,"with_capacity","","Create a `Message` with space for `len` bytes that are initialized to 0.",9,{"inputs":[{"name":"usize"}],"output":{"name":"message"}}],[11,"from_slice","","Create a `Message` from a `&[u8]`. This will copy `data` into the message.",9,null],[11,"as_str","","Return the message content as a string slice if it is valid UTF-8.",9,{"inputs":[{"name":"self"}],"output":{"generics":["str"],"name":"option"}}],[11,"get_more","","Return the `ZMQ_MORE` flag, which indicates if more parts of a multipart message will follow.",9,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"gets","","Query a message metadata property.",9,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"generics":["str"],"name":"option"}}]],"paths":[[4,"SocketType"],[3,"SendMessage"],[3,"SendMultipartMessage"],[3,"ReceiveMultipartMessage"],[3,"ReceiveMessage"],[3,"Context"],[3,"Socket"],[3,"SocketFramed"],[3,"Error"],[3,"Message"]]};
initSearch(searchIndex);
